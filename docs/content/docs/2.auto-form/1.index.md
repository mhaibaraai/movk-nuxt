---
title: Core Concepts (核心概念)
description: 该文档聚焦于 AutoForm 的三大基石：**Schema 构建器 (`afz`)**、**元数据系统 (`meta`)** 以及 **渲染组件 (`MAutoForm`)**。内容力求直观、透彻，强调“为什么这么设计”以及“如何高效使用”。
---

## 介绍

`AutoForm` 的核心理念是 **Schema-First（模式优先）**。不同于传统表单开发需要在 `template` 中手动编写一个个 `<Input>` 组件，AutoForm 允许你将**数据结构**、**验证规则**和**UI 配置**统一收敛在一个 Schema 定义中。

这意味着：**你只需定义一次数据（Source of Truth），表单验证和 UI 渲染将自动完成。**

## 1\. 智能构建器 `afz`

在 `@movk/nuxt` 中，我们不直接使用原生的 `z` 对象（来自 `zod`），而是使用增强版的构建器 **`afz`**。

### 为什么是 `afz`？

虽然 `zod` 是处理数据验证的行业标准，但它本身并不关心 UI（比如输入框的标签是什么？提示语是什么？）。
`afz` 是一个基于 Proxy 的智能代理，它完全兼容 Zod 的所有 API，同时赋予了 Schema **携带 UI 元数据** 的能力。

### 如何使用

通过 `useAutoForm` 组合式函数获取 `afz`：

```ts
<script setup lang="ts">
const { afz } = useAutoForm()

// ✅ 使用 afz 定义字段，可以链式调用 .meta() 配置 UI
const schema = afz.object({
  username: afz.string()
    .min(3, '太短了')
    .meta({
      label: '用户名',
      placeholder: '请输入您的显示名称'
    })
})
</script>
```

> **💡 提示**：
> 如果你混用原生的 `import { z } from 'zod'`，表单验证依然有效，但因为丢失了 UI 元数据，AutoForm 只能渲染出没有任何标签和提示的“裸”输入框。**始终推荐使用 `afz` 来定义表单字段。**

-----

## 2\. 元数据系统 (`.meta`)

`.meta()` 是连接“数据验证”与“界面呈现”的桥梁。它是 AutoForm 中最强大的配置项，允许你在定义字段的同时控制其在页面上的所有表现。

### 常用配置属性

几乎所有的 UI 细节都可以通过 `meta` 对象配置：

```ts
const passwordSchema = afz.string().meta({
  // 1. 基础展示
  label: '登录密码',
  description: '用于登录您的账户',
  placeholder: '********',
  
  // 2. 辅助信息
  hint: '忘记密码？', // 显示在右上角的提示链接或文本
  
  // 3. UI 控件控制
  type: 'password', // HTML input type
  
  // 4. 组件属性透传 (直接传给底层 Nuxt UI 组件)
  inputProps: {
    icon: 'i-lucide-lock', // 添加图标
    color: 'gray',
    variant: 'outline'
  }
})
```

### 元数据层级

`meta` 不仅可以作用于字段，也可以作用于整个对象（用于布局分组，详见[布局系统](https://www.google.com/search?q=/docs/auto-form/layout-system)）：

```ts
const userSchema = afz.object({
  // ...字段
}).meta({
  // 这里的 meta 作用于整个对象容器
  label: '用户基本信息',
  description: '请填写您的真实资料'
})
```

-----

## 3\. 表单组件 `<MAutoForm>`

定义好 Schema 后，`<MAutoForm>` 组件负责将其“翻译”为可交互的 UI。它处理了状态管理、错误回显和提交逻辑。

### 基础用法

```vue
<template>
  <MAutoForm 
    :schema="schema" 
    :action="handleSubmit" 
  />
</template>

<script setup lang="ts">
const { afz } = useAutoForm()

const schema = afz.object({
  email: afz.string().email().meta({ label: '邮箱' })
})

// action 函数接收验证通过后的数据
const handleSubmit = async (data: any) => {
  console.log('提交成功:', data)
  // await api.login(data)
}
</script>
```

### 核心 Props 解析

| Prop | 类型 | 必填 | 说明 |
| :--- | :--- | :---: | :--- |
| `schema` | `ZodObject` | ✅ | 由 `afz.object(...)` 定义的表单结构。 |
| `action` | `Function` | - | 表单提交时的回调函数。仅在**验证通过**后触发，支持 `async`。 |
| `state` | `Object` | - | (可选) 初始表单数据。如果你需要编辑已有数据，请传入此对象。 |
| `fieldConfig` | `Object` | - | (可选) 全局字段配置，用于统一设置某些属性。 |

### 数据流向

`<MAutoForm>` 内部维护了一份响应式状态。

1.  **初始状态**：如果提供了 `state` prop，表单会以该对象作为初始值（Shallow Clone）。
2.  **双向绑定**：虽然你可以通过 `v-model` 绑定整个表单状态，但在大多数场景下（如提交表单），推荐使用 `action` 回调获取最终的**清洗后数据（Sanitized Data）**。

-----

## 总结

AutoForm 的核心工作流可以概括为：

1.  **Define (定义)**: 使用 `afz` 构建 Schema，利用 `.refine()` 编写验证，利用 `.meta()` 描述 UI。
2.  **Render (渲染)**: 将 Schema 传递给 `<MAutoForm>`。
3.  **Execute (执行)**: 用户交互触发验证，通过后执行 `action`。

这种模式遵循 **DRY (Don't Repeat Yourself)** 原则，极大地减少了在 Template 和 Script 之间来回跳转同步字段名的心智负担。

-----

### 下一步

现在你已经理解了核心概念，可以开始探索具体的字段类型实现：
👉 **[前往：字段类型 (Field Types)](https://www.google.com/search?q=/docs/auto-form/field-types)**
