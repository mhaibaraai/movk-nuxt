---
title: 布局系统
description: 使用布局系统灵活控制表单字段的视觉呈现和组织结构
---

## 概述

布局系统是 AutoForm 的核心特色之一,允许你在不影响数据结构的前提下,灵活控制表单字段的视觉呈现。通过 `afz.layout`,你可以将字段组织在网格、手风琴、标签页等各种布局容器中。

::callout{icon="i-lucide-sparkles" color="primary"}
**核心特性**
- **视图与数据分离** - 布局字段不存储数据,仅用于视觉组织
- **响应式配置** - 支持根据表单状态动态调整布局
- **无限嵌套** - 可以在布局中嵌套其他布局,构建复杂结构
- **组件兼容** - 支持任何 Vue 组件作为布局容器
::

## 基础用法

### 简单容器布局

使用 `afz.layout` 创建一个基础的容器布局,通过 `class` 属性控制样式:

```vue
<script setup lang="ts">
const { afz } = useAutoForm()

const schema = afz.object({
  $layout: afz.layout({
    class: 'space-y-4',
    fields: {
      firstName: afz.string(),
      lastName: afz.string(),
      email: afz.email()
    }
  })
})
</script>
```

::note
布局字段的 key(如 `$layout`)以 `$` 开头是惯例写法,但不是必需的。你可以使用任何字段名,只要其值为 `afz.layout()` 即可。
::

### 网格布局

使用 CSS Grid 创建多列布局,通过字段级别的 `class` 控制跨列:

::component-example
---
name: 'auto-form-layout-grid-example'
collapse: true
---
::

::tip
使用 Tailwind CSS 的网格类(`grid-cols-*`, `col-span-*`)可以轻松实现复杂的响应式布局。
::

### 响应式多列布局

利用 Tailwind 的响应式前缀,创建自适应不同屏幕尺寸的布局:

```vue
<script setup lang="ts">
const { afz } = useAutoForm()

const schema = afz.object({
  $responsive: afz.layout({
    // 移动端 1 列,平板 2 列,桌面端 3 列
    class: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4',
    fields: {
      title: afz.string().meta({
        class: 'col-span-full',  // 所有屏幕尺寸都占满整行
        label: '标题'
      }),
      firstName: afz.string().meta({ label: '名字' }),
      lastName: afz.string().meta({ label: '姓氏' }),
      email: afz.email().meta({ label: '邮箱' }),
      description: afz.string({ type: 'textarea' }).meta({
        class: 'col-span-full',
        label: '描述'
      })
    }
  })
})
</script>
```

## 高级布局容器

### 手风琴布局

使用 Nuxt UI 的 `UAccordion` 组件,将字段组织在可折叠的面板中:

::component-example
---
name: 'auto-form-layout-accordion-example'
collapse: true
---
::

::tip
`fieldSlots` 用于将不同字段分配到布局组件的不同插槽中。插槽名称需要与 `items` 中定义的 `slot` 对应。
::

### 标签页布局

使用 `UTabs` 组件创建分页式表单,支持响应式配置:

```vue
<script setup lang="ts">
import { UTabs } from '#components'
const { afz } = useAutoForm()

const schema = afz.object({
  userType: afz.enum(['personal', 'company']).meta({ label: '用户类型' }),

  $tabs: afz.layout({
    component: UTabs,
    // 根据 userType 动态配置标签页
    props: ({ state }) => {
      const isCompany = state?.userType === 'company'
      return {
        ui: { content: 'space-y-4' },
        items: isCompany
          ? [
              { label: '公司信息', icon: 'i-lucide-building', slot: 'tab-0' },
              { label: '联系方式', icon: 'i-lucide-phone', slot: 'tab-1' }
            ]
          : [
              { label: '个人信息', icon: 'i-lucide-user', slot: 'tab-0' },
              { label: '联系方式', icon: 'i-lucide-phone', slot: 'tab-1' }
            ]
      }
    },
    // 根据 userType 动态分配字段到不同标签页
    fieldSlots: ({ state }) => {
      if (state?.userType === 'company') {
        return {
          companyName: 'tab-0',
          phone: 'tab-1',
          address: 'tab-1'
        }
      }
      return {
        username: 'tab-0',
        phone: 'tab-1',
        address: 'tab-1'
      }
    },
    fields: {
      username: afz.string().meta({
        label: '姓名',
        if: ({ state }) => state?.userType === 'personal'
      }).optional(),
      companyName: afz.string().meta({
        label: '公司名称',
        if: ({ state }) => state?.userType === 'company'
      }).optional(),
      phone: afz.string().meta({ label: '联系电话' }),
      address: afz.string().meta({ label: '地址' })
    }
  })
})
</script>
```

::warning
在使用条件渲染(`if`)时,建议将字段标记为 `.optional()`,避免验证错误。
::

## 布局配置详解

### AutoFormLayoutConfig

`afz.layout` 接受一个配置对象,包含以下属性:

| 属性 | 类型 | 说明 |
|------|------|------|
| `component`{lang="ts-type"} | `Component \| string` | 布局容器组件(默认:`'div'`) |
| `class`{lang="ts-type"} | `string \| (context) => string` | CSS 类名,支持响应式函数 |
| `props`{lang="ts-type"} | `object \| (context) => object` | 组件属性,支持响应式函数 |
| `slots`{lang="ts-type"} | `Record<string, () => VNode> \| (context) => ...` | 组件插槽内容 |
| `fields`{lang="ts-type"} | `Record<string, ZodType>` | 包含的字段定义 |
| `fieldSlot`{lang="ts-type"} | `string \| (context) => string` | 将**所有**字段渲染到指定插槽 |
| `fieldSlots`{lang="ts-type"} | `Record<string, string> \| (context) => ...` | 将**不同**字段分配到不同插槽 |

### 响应式配置函数

`class`、`props`、`slots`、`fieldSlot` 和 `fieldSlots` 都支持响应式函数,接收一个上下文对象:

```ts
interface LayoutContext {
  state: FormState          // 表单当前状态
  path: string             // 布局字段的路径
  value: any               // 布局字段的值(通常为空)
  setValue: (value) => void // 设置值的函数
}
```

**示例**:

```ts
afz.layout({
  class: ({ state }) => state?.mode === 'advanced'
    ? 'grid grid-cols-3 gap-4'
    : 'space-y-4',

  props: ({ state }) => ({
    disabled: state?.readOnly === true
  })
})
```

### fieldSlot vs fieldSlots

- **`fieldSlot`** - 将所有字段渲染到同一个插槽,适用于简单场景:

```ts
afz.layout({
  component: UAccordion,
  fieldSlot: 'content',  // 所有字段都渲染到 'content' 插槽
  fields: { /* ... */ }
})
```

- **`fieldSlots`** - 精确控制每个字段的插槽位置,适用于分组场景:

```ts
afz.layout({
  component: UAccordion,
  fieldSlots: {
    name: 'panel-1',
    email: 'panel-1',
    bio: 'panel-2'
  },
  fields: { /* ... */ }
})
```

## 嵌套布局

布局字段可以无限嵌套,构建复杂的层级结构:

::component-example
---
name: 'auto-form-layout-nested-example'
collapse: true
---
::

::note
嵌套布局的深度没有限制,但过深的嵌套可能影响可读性。建议保持在 2-3 层。
::

## 数据提取机制

布局字段在数据验证时会被**自动展开**为其内部的实际数据字段:

```ts
const schema = afz.object({
  $layout: afz.layout({
    fields: {
      name: afz.string(),
      email: afz.email()
    }
  })
})

// 表单数据结构(不包含 $layout)
const formData = {
  name: 'John',
  email: 'john@example.com'
}
```

这个机制由 `extractPureSchema` 函数实现,它会递归遍历 schema,提取所有布局字段中的实际数据字段,生成一个"纯净"的验证 schema。

::tip
这意味着你可以自由调整布局结构,而不影响现有的数据结构或验证逻辑。
::

## 使用场景

### 简单分组

使用基础容器布局对相关字段进行视觉分组:

```ts
const schema = afz.object({
  $basic: afz.layout({
    class: 'p-4 border rounded-lg space-y-4',
    fields: {
      username: afz.string(),
      password: afz.string({ type: 'withPasswordToggle' })
    }
  }),

  $advanced: afz.layout({
    class: 'p-4 border rounded-lg space-y-4 mt-4',
    fields: {
      apiKey: afz.string(),
      webhook: afz.url()
    }
  })
})
```

### 多步骤表单

结合 `UTabs` 组件实现向导式表单:

```ts
const schema = afz.object({
  $wizard: afz.layout({
    component: UTabs,
    props: {
      items: [
        { label: '第 1 步:基本信息', slot: 'step-1' },
        { label: '第 2 步:联系方式', slot: 'step-2' },
        { label: '第 3 步:确认提交', slot: 'step-3' }
      ]
    },
    fieldSlots: {
      name: 'step-1',
      email: 'step-2',
      summary: 'step-3'
    },
    fields: { /* ... */ }
  })
})
```

### 动态表单分组

根据表单状态动态调整字段分组:

```ts
const schema = afz.object({
  accountType: afz.enum(['basic', 'premium']),

  $features: afz.layout({
    component: UAccordion,
    props: ({ state }) => ({
      items: state?.accountType === 'premium'
        ? [
            { label: '基础功能', slot: 'basic' },
            { label: '高级功能', slot: 'premium' }
          ]
        : [{ label: '基础功能', slot: 'basic' }]
    }),
    fieldSlots: ({ state }) => ({
      feature1: 'basic',
      feature2: state?.accountType === 'premium' ? 'premium' : 'basic'
    }),
    fields: { /* ... */ }
  })
})
```

## 最佳实践

### 1. 语义化的布局 key

使用有意义的字段名,以 `$` 前缀标识布局字段:

```ts
// ✅ 推荐
$personalInfo: afz.layout({ /* ... */ })
$addressDetails: afz.layout({ /* ... */ })

// ❌ 不推荐
layout1: afz.layout({ /* ... */ })
container: afz.layout({ /* ... */ })
```

### 2. 合理使用嵌套

避免过度嵌套,保持结构清晰:

```ts
// ✅ 推荐:2 层嵌套,结构清晰
afz.object({
  $section1: afz.layout({
    fields: {
      field1: afz.string(),
      $subsection: afz.layout({
        fields: { /* ... */ }
      })
    }
  })
})

// ❌ 不推荐:4 层嵌套,过于复杂
afz.object({
  $a: afz.layout({
    fields: {
      $b: afz.layout({
        fields: {
          $c: afz.layout({
            fields: {
              $d: afz.layout({ /* ... */ })
            }
          })
        }
      })
    }
  })
})
```

### 3. 响应式函数的性能

响应式函数会在表单状态变化时重新计算,避免复杂的计算逻辑:

```ts
// ✅ 推荐:简单的条件判断
props: ({ state }) => ({
  disabled: state?.readOnly === true
})

// ⚠️ 注意:复杂计算可能影响性能
props: ({ state }) => ({
  items: state?.list
    ?.filter(item => item.active)
    ?.map(item => ({ ...item, processed: heavyComputation(item) }))
})
```

### 4. 结合条件渲染

使用 `if` 元数据配合布局,实现更灵活的表单:

```ts
afz.layout({
  fields: {
    basicField: afz.string(),
    advancedField: afz.string().meta({
      if: ({ state }) => state?.mode === 'advanced'
    }).optional()
  }
})
```

## 常见问题

### 布局字段是否占用表单数据?

不会。布局字段在数据验证时会被自动展开,最终的表单数据只包含实际的数据字段。

### 可以在布局中使用对象或数组字段吗?

可以。`afz.layout` 的 `fields` 支持任何 Zod 类型,包括对象、数组等复杂类型。

### 如何为布局容器添加标题?

使用布局组件的 `slots` 配置或 `props` 传递标题:

```ts
afz.layout({
  component: UCard,
  props: {
    title: '个人信息',
    description: '请填写您的基本信息'
  },
  fields: { /* ... */ }
})
```

### 响应式配置函数何时触发?

当 `state` 对象的任何属性发生变化时,响应式函数会重新计算。建议使用具体的字段值作为判断依据,避免不必要的重算。
