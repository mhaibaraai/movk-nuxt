---
title: useApiFetch
description: 基于 Nuxt useFetch 封装的 API 请求 composable，提供自动认证、业务状态码检查和 Toast 提示。
---

## Usage

使用自动导入的 `useApiFetch` composable 进行 API 请求，基于 Nuxt [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) 封装，提供自动认证、数据解包、业务状态码检查和统一的错误处理。

```vue
<script setup lang="ts">
interface User {
  id: number
  name: string
  email: string
}

// 基础用法(自动解包 data 字段)
const { data, pending, error, refresh } = await useApiFetch<User[]>('/users')

// POST 请求
const { data } = await useApiFetch('/users', {
  method: 'POST',
  body: { name: 'test', email: 'test@example.com' }
})

// 使用其他端点
const { data } = await useApiFetch('/users', { endpoint: 'v2' })
</script>
```

- `useApiFetch` 继承 Nuxt [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) 的所有功能，同时提供额外的 API 集成特性。
- 自动从 session 获取 token 并添加到请求头(通过 `$api` 实例)。
- 自动检查业务状态码并抛出错误。
- 内置 Toast 提示，支持自定义配置。

::note
`useApiFetch` 在服务端和客户端均可执行。如需仅在客户端执行请求，请使用 [`useClientApiFetch`](/docs/composables/use-client-api-fetch)。

完整的 `useFetch` 选项参考: [Nuxt useFetch 文档](https://nuxt.com/docs/api/composables/use-fetch)
::

::tip{icon="i-lucide-settings" to="/docs/getting-started/configuration#api"}
了解 API 系统的全局配置选项，包括端点、认证、Toast 等
::


## 数据解包

`useApiFetch` 会自动解包 API 响应的 `data` 字段:

```ts
// API 响应格式
{
  code: 200,
  message: 'Success',
  data: { id: 1, name: 'test' }  // 这部分会被自动解包
}

// 使用时直接声明 data 字段的类型
const { data } = await useApiFetch<User>('/user')
// data.value = { id: 1, name: 'test' }
```

如果响应格式不同，可以使用 `skipBusinessCheck` 跳过解包，或使用 `transform` 自定义转换逻辑。

## 业务状态码检查

默认情况下，`useApiFetch` 会检查业务状态码(通过模块配置的 `response` 选项):

```ts
// 默认配置
{
  response: {
    codeKey: 'code',
    successCodes: [200, 0]
  }
}
```

当业务状态码不匹配时，会自动抛出错误并显示 Toast:

```ts
// 业务状态码错误
{
  code: 400,
  message: '用户名已存在'
}
// 自动抛出错误，显示 Toast: "用户名已存在"
```

可以通过 `skipBusinessCheck: true` 禁用此功能:

```ts
const { data } = await useApiFetch('/users', {
  skipBusinessCheck: true
})
```

## Toast 提示

内置 Toast 提示，支持请求级配置:

```ts
// 禁用所有 Toast
const { data } = await useApiFetch('/users', {
  toast: false
})

// 仅显示错误提示
const { data } = await useApiFetch('/users', {
  toast: { success: false }
})

// 使用快捷文本
const { data } = await useApiFetch('/users', {
  toast: {
    successMessage: '创建成功!',
    errorMessage: '创建失败,请重试'
  }
})

// 使用完整的 Toast 属性
const { data } = await useApiFetch('/users', {
  toast: {
    success: {
      title: '创建成功',
      description: '用户已添加到系统',
      color: 'primary',
      icon: 'i-lucide-circle-check'
    },
    error: {
      title: '创建失败',
      description: '请检查输入信息',
      color: 'danger',
      timeout: 5000
    }
  }
})
```

## 自定义 Hooks

### 请求级 Hooks

每个 `useApiFetch` 调用可以传入请求级钩子，与内置钩子**合并执行**（内置先执行，用户后执行）:

```ts
const { data } = await useApiFetch('/users', {
  onRequest({ request, options }) {
    console.log('发送请求:', request)
  },
  onRequestError({ request, error }) {
    console.error('请求错误:', error)
  },
  onResponse({ response }) {
    console.log('收到响应:', response._data)
  },
  onResponseError({ response }) {
    console.error('响应错误:', response.status)
  }
})
```

::tip
请求级钩子会在内置钩子**之后**执行，不会覆盖内置的认证和 Toast 逻辑。
::

### 全局 Hooks（覆盖内置行为）

如需**覆盖**内置钩子的行为（如自定义 401 处理、替换认证逻辑），使用 `useApiHooks` 在插件中注册全局钩子:

```ts
// plugins/api-hooks.ts
export default defineNuxtPlugin(() => {
  useApiHooks({
    async onResponseError(context, builtin) {
      if (context.response.status === 401) {
        // 自定义 401 处理：尝试刷新 token
        const refreshed = await tryRefreshToken()
        if (refreshed) return // 跳过内置 401 处理
      }
      await builtin(context) // 其他错误走内置处理（Toast 提示等）
    }
  })
})
```

每个钩子接收两个参数:

- `context` — ofetch 的请求/响应上下文
- `builtin` — 内置钩子函数，调用它执行默认行为，不调用则完全覆盖

4 个可覆盖的内置钩子:

| 钩子 | 内置行为 |
|------|---------|
| `onRequest` | 认证 header 注入、debug 日志 |
| `onRequestError` | debug 错误日志 |
| `onResponse` | 业务状态码检查、成功 Toast |
| `onResponseError` | 401 未授权处理、错误 Toast |

还可以按端点配置不同的钩子:

```ts
// plugins/api-hooks.ts
export default defineNuxtPlugin(() => {
  useApiHooks({
    hooks: {
      // 全局钩子（所有端点）
      onRequest(context, builtin) {
        builtin(context)
        console.log('所有请求的自定义日志')
      }
    },
    endpoints: {
      // 仅 payment 端点
      payment: {
        onResponseError(context, builtin) {
          // payment 端点的专属错误处理
        }
      }
    }
  })
})
```

::note
钩子解析优先级: **端点级钩子** > **全局钩子** > **内置钩子**。
::

### Hooks 层级对比

| 层级 | 注册方式 | 与内置钩子的关系 | 适用场景 |
|------|---------|-----------------|---------|
| 请求级 | `useApiFetch` 的 `onXxx` 选项 | 合并执行（追加） | 单个请求的额外处理 |
| 全局/端点级 | `useApiHooks` (在 `defineNuxtPlugin` 内) | 可覆盖（通过 `builtin` 控制） | 自定义 401、认证逻辑等 |

## API

### useApiFetch()

`useApiFetch<ResT = unknown, DataT = ResT>(url: string | (() => string), options?: UseApiFetchOptions<ResT, DataT>): UseApiFetchReturn<DataT>`{lang="ts-type"}

创建 API 请求。

#### Parameters

::field-group
  ::field{name="url" type="string | (() => string)" required}
  请求 URL 或返回 URL 的函数。支持响应式 URL。
  ::

  ::field{name="options" type="UseApiFetchOptions<ResT, DataT>"}
  请求配置选项。支持所有 Nuxt `useFetch` 选项，以及额外的 API 集成选项。

    ::collapsible

      **API 集成选项**

      ::field-group
        ::field{name="endpoint" type="string"}
        使用指定的端点配置。默认使用 `$api` 的默认端点。
        ::

        ::field{name="toast" type="RequestToastOptions | false"}
        Toast 提示配置。设为 `false` 禁用 Toast。

          ::collapsible

            ::field-group
              ::field{name="success" type="Partial<ToastProps> | false"}
              成功提示配置。可以是完整的 Toast 属性对象，或 `false` 禁用成功提示。
              ::

              ::field{name="error" type="Partial<ToastProps> | false"}
              错误提示配置。可以是完整的 Toast 属性对象，或 `false` 禁用错误提示。
              ::

              ::field{name="successMessage" type="string"}
              成功提示的快捷文本。等价于 `success: { title: '...' }`。
              ::

              ::field{name="errorMessage" type="string"}
              错误提示的快捷文本。等价于 `error: { title: '...' }`。
              ::
            ::
          ::
        ::

        ::field{name="skipBusinessCheck" type="boolean"}
        跳过业务状态码检查。默认 `false`。
        ::
      ::

      **请求选项** (继承自 `useFetch`)

      ::field-group
        ::field{name="method" type="'GET' | 'HEAD' | 'PATCH' | 'POST' | 'PUT' | 'DELETE' | 'CONNECT' | 'OPTIONS' | 'TRACE'"}
        HTTP 请求方法。默认 `'GET'`。
        ::

        ::field{name="query" type="Record<string, any>"}
        URL 查询参数，会自动序列化到 URL。
        ::

        ::field{name="params" type="Record<string, any>"}
        `query` 的别名。
        ::

        ::field{name="body" type="RequestInit['body'] | Record<string, any>"}
        请求体。对于 POST/PUT/PATCH 请求，会自动序列化为 JSON。
        ::

        ::field{name="headers" type="Record<string, string> | [key: string, value: string][] | Headers"}
        请求头。
        ::

        ::field{name="baseURL" type="string"}
        基础 URL。通常通过 `endpoint` 选项配置，无需手动设置。
        ::
      ::

      **响应处理**

      ::field-group
        ::field{name="transform" type="(input: ResT) => DataT | Promise<DataT>"}
        转换响应数据的函数。接收解包后的 `data` 字段，返回最终数据。
        ::

        ::field{name="pick" type="string[]"}
        仅选择响应数据的指定字段。
        ::

        ::field{name="default" type="() => DataT"}
        设置默认值的工厂函数。
        ::
      ::

      **执行选项**

      ::field-group
        ::field{name="immediate" type="boolean"}
        是否立即执行请求。设为 `false` 时需手动调用 `execute()`。默认 `true`。
        ::

        ::field{name="lazy" type="boolean"}
        是否使用 lazy 模式。lazy 模式下不会阻塞导航，初始 `pending` 为 `false`。默认 `false`。
        ::

        ::field{name="server" type="boolean"}
        是否在服务端执行请求。默认 `true`。
        ::

        ::field{name="watch" type="MultiWatchSources"}
        监听的响应式源，变化时自动重新请求。可以是 ref、reactive 对象或数组。
        ::

        ::field{name="deep" type="boolean"}
        是否深度监听 `watch` 的对象。默认 `true`。
        ::
      ::

      **缓存与去重**

      ::field-group
        ::field{name="key" type="string"}
        自定义缓存键。用于多个请求之间共享数据或去重。
        ::

        ::field{name="dedupe" type="'cancel' | 'defer'"}
        重复请求的处理策略。默认 `cancel`

        - `'cancel'` - 取消待处理的请求
        - `'defer'` - 不发起新请求
        ::

        ::field{name="getCachedData" type="(key: string) => DataT"}
        从缓存中获取数据的函数。返回值将用作初始 `data`。
        ::
      ::

      **请求钩子**

      ::field-group

        ::field{name="onRequest" type="(context: FetchContext) => Promise<void> | void"}
        请求发送前的钩子。与内置钩子合并执行。

          ::collapsible
          ```ts
          onRequest({ request, options }) {
            console.log('发送请求:', request.url)
          }
          ```
          ::
        ::

        ::field{name="onRequestError" type="(context: FetchContext & { error: Error }) => Promise<void> | void"}
        请求错误时的钩子。与内置钩子合并执行。

          ::collapsible
          ```ts
          onRequestError({ request, error }) {
            console.error('请求错误:', error)
          }
          ```
          ::
        ::

        ::field{name="onResponse" type="(context: FetchContext & { response: Response }) => Promise<void> | void"}
        收到响应时的钩子。与内置钩子合并执行。

          ::collapsible
            ```ts
            onResponse({ response }) {
              console.log('收到响应:', response.status)
            }
            ```
          ::
        ::

        ::field{name="onResponseError" type="(context: FetchContext & { response: Response }) => Promise<void> | void"}
        响应错误时的钩子(4xx/5xx)。与内置钩子合并执行。

          ::collapsible
            ```ts
            onResponseError({ response }) {
              console.error('响应错误:', response.status)
            }
            ```
          ::
        ::
      ::
    ::
  ::
::

#### Type Parameters

::field-group
  ::field{name="ResT" type="type"}
  API 响应中 `data` 字段的原始类型。
  ::

  ::field{name="DataT" type="type"}
  `transform` 转换后的最终类型。默认等于 `ResT`。
  ::
::

#### Returns

返回 [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch#return-values) 的响应对象，包含以下属性:

::field-group
  ::field{name="data" type="Ref<DataT | null>"}
  响应数据(已解包和转换)。初始值为 `null`，请求成功后更新为实际数据。
  ::

  ::field{name="error" type="Ref<FetchError | null>"}
  错误对象。包含网络错误、业务状态码错误等。
  ::

  ::field{name="status" type="Ref<'idle' | 'pending' | 'success' | 'error'>"}
  请求状态。

  - `'idle'` - 尚未开始(仅 `immediate: false` 时)
  - `'pending'` - 请求进行中
  - `'success'` - 请求成功
  - `'error'` - 请求失败
  ::

  ::field{name="pending" type="Ref<boolean>"}
  是否正在请求中。等价于 `status.value === 'pending'`。
  ::

  ::field{name="refresh" type="(opts?: { dedupe?: boolean }) => Promise<void>"}
  刷新数据，重新执行请求。别名: `execute`。

    ::collapsible
      ```ts
      // 刷新数据
      await refresh()

      // 跳过去重检查，强制刷新
      await refresh({ dedupe: false })
      ```
    ::
  ::

  ::field{name="execute" type="(opts?: { dedupe?: boolean }) => Promise<void>"}
  `refresh` 的别名。手动执行请求(常用于 `immediate: false` 时)。
  ::

  ::field{name="clear" type="() => void"}
  清空状态。将 `data` 设为 `null`、`error` 设为 `null`、`status` 设为 `'idle'`。
  ::
::

## Changelog

:commit-changelog{prefix="/composables" suffix="ts"}
