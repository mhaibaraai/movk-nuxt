import type { AnyObject } from '@movk/core'
import type { GlobalMeta, z } from 'zod/v4'
import type { IsComponent } from '../core'
import type { AutoFormControl, AutoFormControls } from '../types'
import { isFunction } from '@movk/core'
import defu from 'defu'
import { joinPath, startCase, toPath } from '../core'

interface AutoFormIntrospectedField {
  path: string
  schema: z.ZodType
  originalSchema: z.ZodType
  zodType: string
  meta: GlobalMeta & { props?: AnyObject, slots?: AnyObject }
  decorators: {
    isOptional: boolean
    defaultValue?: any
    description?: string
  }
}

/**
 * 按“外层 → 内层”依次遍历 zod 装饰器链，最终产出核心 schema。
 */
function* iterateZodChain(root: z.ZodType): Generator<any, any, any> {
  let cur: any = root
  for (;;) {
    yield cur
    if (cur?.def?.innerType) {
      cur = cur.def.innerType
    }
    else {
      return cur
    }
  }
}

/**
 * 提取schema核心信息，保留装饰器信息
 */
function extractSchemaInfo(schema: z.ZodType): {
  coreSchema: z.ZodType
  decorators: { isOptional: boolean, defaultValue?: any, description?: string }
  mergedMeta: GlobalMeta
} {
  let isOptional = false
  let defaultValue: any
  let description: string | undefined
  let coreSchema: z.ZodType = schema
  let mergedMeta: GlobalMeta = {}

  for (const node of iterateZodChain(schema)) {
    // 收集 meta（外层覆盖内层）
    if (node?.meta && typeof node.meta === 'function') {
      const m = node.meta() as GlobalMeta
      if (m && Object.keys(m).length > 0) {
        mergedMeta = { ...m, ...mergedMeta }
      }
    }

    // 收集装饰器
    if (node?.def?.type === 'optional') {
      isOptional = true
    }
    if (node?.def?.type === 'default') {
      defaultValue = isFunction(node.def.defaultValue)
        ? node.def.defaultValue()
        : node.def.defaultValue
    }
    if (node?.description) {
      description = node.description
    }

    coreSchema = node as z.ZodType
  }

  return {
    coreSchema,
    decorators: { isOptional, defaultValue, description },
    mergedMeta,
  }
}

/**
 * 递归地分析 Zod schema，返回一个包含所有字段信息的数组
 */
export function introspectSchema(schema: z.ZodType, parentPath?: string): AutoFormIntrospectedField[] {
  const result: AutoFormIntrospectedField[] = []
  const { coreSchema, decorators, mergedMeta } = extractSchemaInfo(schema)
  const type = (coreSchema as any).type

  if (type === 'object') {
    const shape = (coreSchema as any).shape
    for (const key of Object.keys(shape)) {
      const child = shape[key] as z.ZodType
      const path = joinPath([...(parentPath ? toPath(parentPath) : []), key])
      result.push(...introspectSchema(child, path))
    }
    return result
  }

  // if (type === 'array') {
  //   const item = (coreSchema as any).element as z.ZodType
  //   const path = joinPath([...(parentPath ? [parentPath] : []), 0])
  //   result.push(...introspectSchema(item, path))
  //   return result
  // }

  const fieldName = parentPath ? parentPath.split('.').pop() || '' : ''
  const autoGeneratedLabel = fieldName ? startCase(fieldName) : ''

  const finalDescription = mergedMeta.description || decorators.description
  const finalLabel = mergedMeta.label || autoGeneratedLabel
  const finalRequired = mergedMeta.required !== undefined
    ? mergedMeta.required
    : !decorators.isOptional

  result.push({
    path: parentPath ?? '',
    schema: coreSchema,
    originalSchema: schema,
    zodType: type,
    meta: {
      ...mergedMeta,
      label: finalLabel,
      description: finalDescription,
      required: finalRequired,
    },
    decorators,
  })
  return result
}

/**
 * 解析控制器
 */
export function resolveControl(entry: AutoFormIntrospectedField, mapping: AutoFormControls) {
  const meta = entry.meta || {}

  let chosenType: string | undefined
  let chosenComponent: IsComponent | undefined
  let mapped: AutoFormControl<IsComponent> | undefined

  if (meta.component) {
    chosenComponent = meta.component
  }
  else if (meta.type) {
    chosenType = meta.type as string
    mapped = mapping[meta.type as keyof typeof mapping]
    chosenComponent = mapped?.component
  }
  else {
    chosenType = entry.zodType
    mapped = mapping[entry.zodType]
    chosenComponent = mapped?.component
  }

  const props = defu(meta.props, mapped?.props)
  const slots = defu(meta.slots, mapped?.slots)

  return {
    type: chosenType,
    component: chosenComponent,
    props,
    slots,
  }
}
