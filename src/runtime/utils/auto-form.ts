import type { GlobalMeta, z } from 'zod/v4'
import type { IsComponent } from '../core'
import type { AutoFormControl, AutoFormControls, AutoFormControlsMeta, FieldContext, ReactiveValue } from '../types'
import { isFunction } from '@movk/core'
import defu from 'defu'
import { Fragment, h, isRef, isVNode, unref } from 'vue'
import { joinPath, startCase, toPath } from '../core'

interface AutoFormIntrospectedField {
  path: string
  schema: z.ZodType
  originalSchema: z.ZodType
  meta: GlobalMeta & AutoFormControlsMeta
  controlMeta: AutoFormControlsMeta
}

/**
 * 按“外层 → 内层”依次遍历 zod 装饰器链
 */
function* iterateZodChain(root: z.ZodType): Generator<any> {
  let cur: any = root
  while (cur) {
    yield cur
    cur = cur?.def?.innerType
  }
}

/**
 * 提取 schema 信息
 */
function extractSchemaInfo(schema: z.ZodType) {
  const decorators = {
    isOptional: false,
    defaultValue: undefined as any,
    description: undefined as string | undefined,
  }

  let mergedMeta: GlobalMeta = {}
  let coreSchema: z.ZodType = schema

  for (const node of iterateZodChain(schema)) {
    // 收集 meta
    if (node?.meta && isFunction(node.meta)) {
      mergedMeta = { ...node.meta(), ...mergedMeta }
    }

    // 收集装饰器信息
    const defType = node?.def?.type
    if (defType === 'optional')
      decorators.isOptional = true
    if (defType === 'default') {
      decorators.defaultValue = isFunction(node.def.defaultValue)
        ? node.def.defaultValue()
        : node.def.defaultValue
    }
    if (node?.description)
      decorators.description = node.description

    coreSchema = node
  }

  return { coreSchema, decorators, mergedMeta }
}

/**
 * 递归地分析 Zod schema，返回一个包含所有字段信息的数组
 */
export function introspectSchema(schema: z.ZodType, parentPath?: string): AutoFormIntrospectedField[] {
  const result: AutoFormIntrospectedField[] = []
  const { coreSchema, decorators, mergedMeta } = extractSchemaInfo(schema)
  const type = (coreSchema as any).type

  if (type === 'object') {
    const shape = (coreSchema as any).shape
    for (const key of Object.keys(shape)) {
      const child = shape[key] as z.ZodType
      const path = joinPath([...(parentPath ? toPath(parentPath) : []), key])
      result.push(...introspectSchema(child, path))
    }
    return result
  }

  // if (type === 'array') {
  //   const item = (coreSchema as any).element as z.ZodType
  //   const path = joinPath([...(parentPath ? [parentPath] : []), 0])
  //   result.push(...introspectSchema(item, path))
  //   return result
  // }

  const finalType = mergedMeta.component ? undefined : (mergedMeta.type ?? type)
  const fieldName = parentPath ? parentPath.split('.').pop() || '' : ''
  const autoGeneratedLabel = fieldName ? startCase(fieldName) : ''

  // 保留原始响应式值，不进行静态解析
  const finalDescription = mergedMeta.description ?? decorators.description
  const finalLabel = mergedMeta.label ?? autoGeneratedLabel
  // required 只在没有明确设置时使用装饰器的值
  const finalRequired = mergedMeta.required ?? !decorators.isOptional

  result.push({
    path: parentPath ?? '',
    schema: coreSchema,
    originalSchema: schema,
    meta: {
      ...mergedMeta,
      type: finalType,
      label: finalLabel,
      description: finalDescription,
      required: finalRequired,
    },
    controlMeta: {} as AutoFormControlsMeta,
  })
  console.log('11', finalType)
  return result
}

/**
 * 解析控制器
 */
export function resolveControlMeta(entry: AutoFormIntrospectedField, mapping: AutoFormControls): AutoFormControlsMeta {
  const meta = entry.meta || {}

  let chosenComponent: IsComponent | undefined
  let mapped: AutoFormControl<IsComponent> | undefined

  if (meta.component) {
    chosenComponent = meta.component
  }
  else if (meta.type) {
    mapped = mapping[meta.type as keyof typeof mapping]
    chosenComponent = mapped?.component
  }

  // 合并 meta 属性和匹配的原始默认的 mapped 属性
  const props = defu(meta.props, mapped?.props)
  const slots = defu(meta.slots, mapped?.slots)
  const hidden = meta.hidden ?? mapped?.hidden
  const cond = meta.if ?? mapped?.if

  return {
    type: meta.type,
    component: chosenComponent,
    props,
    slots,
    hidden,
    if: cond,
  }
}

function normalize(node: any): any[] {
  if (node == null || node === false)
    return []

  if (Array.isArray(node))
    return node.flatMap(n => normalize(n))

  if (isVNode(node))
    return [node]

  const t = typeof node
  if (t === 'string' || t === 'number')
    return [node]

  // 其它对象不参与字符串化，避免触发 JSON.stringify 循环
  return []
}

export function VNodeRender(props: { node: unknown }) {
  const children = normalize(props.node as any)
  if (children.length === 0)
    return null as any
  if (children.length === 1)
    return children[0] as any
  return h(Fragment, null, children)
}

// 响应式值解析函数 - 直接解析，不缓存
export function resolveReactiveValue(value: ReactiveValue<any, FieldContext>, context: FieldContext): any {
  if (typeof value === 'function') {
    return (value as (ctx: FieldContext) => any)(context)
  }
  return unref(value)
}

export function resolveReactiveObject<T extends Record<string, any>>(
  obj: T,
  context: FieldContext,
): T {
  // 处理数组
  if (Array.isArray(obj)) {
    return obj.map((item) => {
      if (typeof item === 'object' && item !== null && !isRef(item) && !isVNode(item)) {
        return resolveReactiveObject(item, context)
      }
      return resolveReactiveValue(item, context)
    }) as unknown as T
  }

  // 处理对象
  const result = {} as T
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'object' && value !== null && !isRef(value) && !isVNode(value)) {
      (result as any)[key] = resolveReactiveObject(value, context)
    }
    else {
      (result as any)[key] = resolveReactiveValue(value, context)
    }
  }
  return result
}
