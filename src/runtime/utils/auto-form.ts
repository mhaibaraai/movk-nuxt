import type { AnyObject } from '@movk/core'
import type { GlobalMeta, z } from 'zod/v4'
import type { IsComponent, ReactiveValue } from '../core'
import type { AccordionConfig, AccordionItem, AutoFormControl, AutoFormControls, AutoFormControlsMeta, AutoFormField, AutoFormFieldContext } from '../types/auto-form'
import { isFunction, isObject } from '@movk/core'
import { Fragment, h, isRef, isVNode, markRaw, unref } from 'vue'
import { joinPath, startCase, toPath } from '../core'

/**
 * 按“外层 → 内层”依次遍历 zod 装饰器链
 */
function* iterateZodChain(root: z.ZodType): Generator<any> {
  let cur: any = root
  while (cur) {
    yield cur
    cur = cur?.def?.innerType
  }
}

/**
 * 提取 schema 信息
 */
function extractSchemaInfo(schema: z.ZodType) {
  const decorators = {
    isOptional: false,
    defaultValue: undefined as any,
    description: undefined as string | undefined,
  }

  let mergedMeta: GlobalMeta & AutoFormControlsMeta = {}
  let coreSchema: z.ZodType = schema

  for (const node of iterateZodChain(schema)) {
    // 收集 meta
    if (node?.meta && isFunction(node.meta)) {
      mergedMeta = { ...node.meta(), ...mergedMeta }
    }

    // 收集装饰器信息
    const defType = node?.def?.type
    if (defType === 'optional')
      decorators.isOptional = true
    if (defType === 'default') {
      decorators.defaultValue = isFunction(node.def.defaultValue)
        ? node.def.defaultValue()
        : node.def.defaultValue
    }
    if (node?.description)
      decorators.description = node.description

    coreSchema = node
  }

  return { coreSchema, decorators, mergedMeta }
}

/**
 * 递归地分析 Zod schema，返回一个包含所有字段信息的数组
 */
export function introspectSchema(
  schema: z.ZodType,
  mapping: AutoFormControls,
  parentPath?: string,
): AutoFormField[] {
  const result: AutoFormField[] = []
  const { coreSchema, decorators, mergedMeta } = extractSchemaInfo(schema)
  const type = (coreSchema as any).type

  // 通用字段信息提取
  const fieldName = parentPath ? parentPath.split('.').pop() || '' : ''
  const autoGeneratedLabel = fieldName ? startCase(fieldName) : ''
  const finalDescription = mergedMeta.description ?? decorators.description
  const finalLabel = mergedMeta.label ?? autoGeneratedLabel
  const finalRequired = mergedMeta.required || !decorators.isOptional

  if (type === 'object') {
    const shape = (coreSchema as any).shape
    // 如果是根级别（parentPath 为空），直接处理子字段，不创建容器
    if (!parentPath) {
      for (const key of Object.keys(shape)) {
        const child = shape[key] as z.ZodType
        result.push(...introspectSchema(child, mapping, key))
      }
      return result
    }

    const accordionItem = {
      path: parentPath ?? '',
      schema: coreSchema,
      originalSchema: schema,
      decorators,
      meta: {
        ...mergedMeta,
        label: finalLabel,
        description: finalDescription,
        required: finalRequired,
      },
      children: [],
    } as AutoFormField

    // 递归处理子字段
    for (const key of Object.keys(shape)) {
      const child = shape[key] as z.ZodType
      const childPath = joinPath([...toPath(parentPath), key])
      accordionItem.children!.push(...introspectSchema(child, mapping, childPath))
    }

    result.push(accordionItem)
    return result
  }

  const finalType = mergedMeta.component ? undefined : (mergedMeta.type ?? type)

  let chosenComponent: IsComponent | undefined
  let mapped: AutoFormControl<IsComponent> | undefined

  if (mergedMeta.component) {
    chosenComponent = mergedMeta.component
  }
  else if (finalType) {
    mapped = mapping[finalType as keyof typeof mapping]
    chosenComponent = mapped?.component
  }

  if (chosenComponent && typeof chosenComponent !== 'string') {
    chosenComponent = markRaw(chosenComponent)
  }

  result.push({
    path: parentPath ?? '',
    schema: coreSchema,
    originalSchema: schema,
    decorators,
    meta: {
      ...mergedMeta,
      type: finalType,
      label: finalLabel,
      description: finalDescription,
      required: finalRequired,
      component: chosenComponent,
      mapped,
    },
  })
  return result
}

function normalize(node: any): any[] {
  if (node == null || node === false)
    return []

  if (Array.isArray(node))
    return node.flatMap(n => normalize(n))

  if (isVNode(node))
    return [node]

  const t = typeof node
  if (t === 'string' || t === 'number')
    return [node]

  // 其它对象不参与字符串化，避免触发 JSON.stringify 循环
  return []
}

export function VNodeRender(props: { node: unknown }) {
  const children = normalize(props.node as any)
  if (children.length === 0)
    return null as any
  if (children.length === 1)
    return children[0] as any
  return h(Fragment, null, children)
}

export function resolveReactiveValue(value: ReactiveValue<any, any>, context: AutoFormFieldContext): any {
  if (isFunction(value)) {
    return (value as (ctx: AutoFormFieldContext) => any)(context)
  }
  return unref(value)
}

export function resolveReactiveObject<T extends Record<string, any>>(
  obj: T,
  context: AutoFormFieldContext,
): T {
  // 处理数组
  if (Array.isArray(obj)) {
    return obj.map((item) => {
      if (isObject(item) && item !== null && !isRef(item) && !isVNode(item)) {
        return resolveReactiveObject(item, context)
      }
      return resolveReactiveValue(item, context)
    }) as unknown as T
  }

  // 处理对象
  const result = {} as T
  for (const [key, value] of Object.entries(obj)) {
    if (isObject(value) && value !== null && !isRef(value) && !isVNode(value)) {
      (result as any)[key] = resolveReactiveObject(value, context)
    }
    else {
      (result as any)[key] = resolveReactiveValue(value, context)
    }
  }
  return result
}

// 增强事件属性函数 - 为Vue组件的事件处理函数注入表单字段上下文
export function enhanceEventProps(originalProps: AnyObject, ctx: AutoFormFieldContext) {
  const next: Record<string, any> = {}
  for (const key of Object.keys(originalProps || {})) {
    const val = (originalProps as any)[key]
    if (/^on[A-Z].+/.test(key) && isFunction(val)) {
      next[key] = (...args: any[]) => (val as any)(...args, ctx)
    }
    else {
      next[key] = val
    }
  }
  return next
}

/**
 * UAccordion 相关工具函数
 */

/**
 * 检测字段是否为对象字段（容器字段）
 * @param field 字段
 * @returns 是否为对象字段
 */
export function isObjectField(field: AutoFormField): boolean {
  return !!(field.children && field.children.length > 0)
}

/**
 * 检测字段是否为叶子节点字段（有控件的字段）
 * @param field 字段
 * @returns 是否为叶子节点字段
 */
export function isLeafField(field: AutoFormField): boolean {
  return !isObjectField(field)
}

/**
 * 递归展平字段列表，只返回叶子节点字段
 * @param fields 字段列表
 * @returns 展平后的叶子节点字段列表
 */
export function flattenFields(fields: AutoFormField[]): AutoFormField[] {
  const result: AutoFormField[] = []

  for (const field of fields) {
    if (isLeafField(field)) {
      // 叶子节点直接添加
      result.push(field)
    }
    else if (field.children) {
      // 对象字段递归展平其子字段
      result.push(...flattenFields(field.children))
    }
  }

  return result
}

/**
 * 检测字段列表中是否包含对象字段
 * @param fields 字段列表
 * @returns 是否包含对象字段
 */
export function hasObjectFields(fields: AutoFormField[]): boolean {
  return fields.some(field => isObjectField(field))
}

/**
 * 将字段按类型分组
 * @param fields 字段列表
 * @returns 分组后的字段
 */
export function groupFieldsByType(fields: AutoFormField[]) {
  const objectFields: AutoFormField[] = []
  const regularFields: AutoFormField[] = []

  for (const field of fields) {
    if (isObjectField(field)) {
      objectFields.push(field)
    }
    else {
      regularFields.push(field)
    }
  }

  return {
    objectFields,
    regularFields,
  }
}

/**
 * 递归收集所有对象字段（包括嵌套的）
 * @param fields 字段列表
 * @returns 所有对象字段的扁平列表
 */
export function collectAllObjectFields(fields: AutoFormField[]): AutoFormField[] {
  const result: AutoFormField[] = []

  for (const field of fields) {
    if (isObjectField(field)) {
      result.push(field)
      // 递归收集子字段中的对象字段
      if (field.children) {
        result.push(...collectAllObjectFields(field.children))
      }
    }
  }

  return result
}

/**
 * 只收集顶级对象字段（不包括嵌套的）
 * @param fields 字段列表
 * @returns 顶级对象字段列表
 */
export function collectTopLevelObjectFields(fields: AutoFormField[]): AutoFormField[] {
  return fields.filter(field => isObjectField(field))
}

/**
 * 生成 UAccordion 的 items 配置
 * @param objectFields 对象字段列表
 * @param config Accordion 配置
 * @returns AccordionItem 数组
 */
export function generateAccordionItems(
  objectFields: AutoFormField[],
  config?: AccordionConfig,
): AccordionItem[] {
  return objectFields.map((field) => {
    // 使用自定义生成器（如果提供）
    if (config?.itemGenerator) {
      return config.itemGenerator(field)
    }

    // 创建字段上下文来解析 ReactiveValue
    const context: AutoFormFieldContext = {
      state: {},
      path: field.path,
      value: undefined,
      setValue: () => {},
    }

    // 解析标签
    const label = field.meta.label
    const resolvedLabel = isFunction(label) ? label(context) : (unref(label) || startCase(field.path))

    // 默认生成逻辑
    const defaultItem: AccordionItem = {
      label: resolvedLabel,
      value: field.path,
      slot: `content-${field.path}`,
    }

    // 应用字段级覆盖配置
    const fieldOverride = config?.fieldOverrides?.[field.path]
    if (fieldOverride) {
      return { ...defaultItem, ...fieldOverride }
    }

    return defaultItem
  })
}

/**
 * 检查是否应该启用 UAccordion 包装
 * @param fields 字段列表
 * @param config Accordion 配置
 * @returns 是否应该启用
 */
export function shouldEnableAccordion(
  fields: AutoFormField[],
  config?: AccordionConfig,
): boolean {
  if (!config?.enabled) {
    return false
  }

  // 如果配置了只对包含对象字段的表单启用
  if (config.onlyForObjectFields !== false) {
    return hasObjectFields(fields)
  }

  return true
}
