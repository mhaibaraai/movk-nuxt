import type { GlobalMeta, z } from 'zod/v4'
import type { IsComponent } from '../../core'
import type { AutoFormControl, AutoFormControls, AutoFormControlsMeta, AutoFormField } from '../../types/auto-form'
import { isFunction } from '@movk/core'
import { markRaw } from 'vue'
import { joinPath, startCase, toPath } from '../../core'

/**
 * 按"外层 → 内层"依次遍历 zod 装饰器链
 */
function* iterateZodChain(root: z.ZodType): Generator<any> {
  let cur: any = root
  while (cur) {
    yield cur
    cur = cur?.def?.innerType
  }
}

/**
 * 提取 schema 信息
 */
function extractSchemaInfo(schema: z.ZodType) {
  const decorators = {
    isOptional: false,
    defaultValue: undefined as any,
    description: undefined as string | undefined,
  }

  let mergedMeta: GlobalMeta & AutoFormControlsMeta = {}
  let coreSchema: z.ZodType = schema

  for (const node of iterateZodChain(schema)) {
    // 收集 meta
    if (node?.meta && isFunction(node.meta)) {
      mergedMeta = { ...node.meta(), ...mergedMeta }
    }

    // 收集装饰器信息
    const defType = node?.def?.type
    if (defType === 'optional')
      decorators.isOptional = true
    if (defType === 'default') {
      decorators.defaultValue = isFunction(node.def.defaultValue)
        ? node.def.defaultValue()
        : node.def.defaultValue
    }
    if (node?.description)
      decorators.description = node.description

    coreSchema = node
  }

  return { coreSchema, decorators, mergedMeta }
}

/**
 * 递归地分析 Zod schema，返回一个包含所有字段信息的数组
 */
export function introspectSchema(
  schema: z.ZodType,
  mapping: AutoFormControls,
  parentPath?: string,
): AutoFormField[] {
  const result: AutoFormField[] = []
  const { coreSchema, decorators, mergedMeta } = extractSchemaInfo(schema)
  const type = (coreSchema as any).type

  // 通用字段信息提取
  const fieldName = parentPath ? parentPath.split('.').pop() || '' : ''
  const autoGeneratedLabel = fieldName ? startCase(fieldName) : ''
  const finalDescription = mergedMeta.description ?? decorators.description
  const finalLabel = mergedMeta.label ?? autoGeneratedLabel
  const finalRequired = mergedMeta.required || !decorators.isOptional

  if (type === 'object') {
    const shape = (coreSchema as any).shape
    // 如果是根级别（parentPath 为空），直接处理子字段，不创建容器
    if (!parentPath) {
      for (const key of Object.keys(shape)) {
        const child = shape[key] as z.ZodType
        result.push(...introspectSchema(child, mapping, key))
      }
      return result
    }

    const accordionItem = {
      path: parentPath ?? '',
      schema: coreSchema,
      originalSchema: schema,
      decorators,
      meta: {
        ...mergedMeta,
        type: 'object',
        label: finalLabel,
        description: finalDescription,
        required: finalRequired,
      },
      children: [],
    } as AutoFormField

    // 递归处理子字段
    for (const key of Object.keys(shape)) {
      const child = shape[key] as z.ZodType
      const childPath = joinPath([...toPath(parentPath), key])
      accordionItem.children!.push(...introspectSchema(child, mapping, childPath))
    }

    result.push(accordionItem)
    return result
  }

  const finalType = mergedMeta.component ? undefined : (mergedMeta.type ?? type)

  let chosenComponent: IsComponent | undefined
  let mapped: AutoFormControl<IsComponent> | undefined

  if (mergedMeta.component) {
    chosenComponent = mergedMeta.component
  }
  else if (finalType) {
    mapped = mapping[finalType as keyof typeof mapping]
    chosenComponent = mapped?.component
  }

  if (chosenComponent && typeof chosenComponent !== 'string') {
    chosenComponent = markRaw(chosenComponent)
  }

  result.push({
    path: parentPath ?? '',
    schema: coreSchema,
    originalSchema: schema,
    decorators,
    meta: {
      ...mergedMeta,
      type: finalType,
      label: finalLabel,
      description: finalDescription,
      required: finalRequired,
      component: chosenComponent,
      mapped,
    },
  })
  return result
}
