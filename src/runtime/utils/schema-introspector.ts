import type { z } from 'zod/v4'
import type { IsComponent } from '@movk/core'
import type { AutoFormControl, AutoFormControls, AutoFormField, AutoFormMergeMeta } from '../types/auto-form'
import { markRaw } from 'vue'
import { z as zod } from 'zod/v4'
import { joinPath, startCase, toPath, isFunction, isObject } from '@movk/core'
import { useAutoForm } from '../composables/useAutoForm'
import { AUTOFORM_LIMITS, AUTOFORM_META } from '../constants/auto-form'
import type { ZodAutoFormFieldMeta } from '../types/zod'

/**
 * 提取 schema 的 decorators 信息
 */
function extractDecorators(schema: z.ZodType): {
  decorators: AutoFormField['decorators']
  coreSchema: z.ZodType
} {
  const decorators: AutoFormField['decorators'] = {}
  let cur: any = schema
  let coreSchema: z.ZodType = schema

  while (cur) {
    const def = cur?.def
    if (!def?.type)
      break
    switch (def.type) {
      case 'optional':
        decorators.isOptional = true
        break
      case 'readonly':
        decorators.isReadonly = true
        break
      case 'default':
        decorators.defaultValue = isFunction(def.defaultValue)
          ? def.defaultValue()
          : def.defaultValue
        break
    }

    const next = def?.innerType
    if (!next)
      break

    cur = next
    coreSchema = next
  }

  /**
   * @deprecated z.describe() 已废弃，建议使用 z.meta({ description: '...' }) 代替
   * @see https://zod.dev/metadata?id=describe
   */
  if (coreSchema.description) {
    decorators.description = coreSchema.description
  }

  return { decorators, coreSchema }
}

/**
 * 提取 schema 信息
 */
function extractSchemaInfo(schema: z.ZodType, globalMeta: ZodAutoFormFieldMeta, autoGeneratedLabel: string) {
  const { getAutoFormMetadata } = useAutoForm()

  const customMeta = getAutoFormMetadata(schema)
  const { decorators, coreSchema } = extractDecorators(schema)
  const computedType = customMeta?.component ? undefined : (customMeta?.type ?? (coreSchema as any)?.type)

  const mergedMeta = {
    ...{
      required: !decorators.isOptional,
      description: decorators.description,
      label: autoGeneratedLabel
    } as AutoFormField['meta'],
    ...globalMeta,
    ...customMeta,
    type: computedType,
    // 如果有 overwrite,则进行合并
    ...(customMeta?.overwrite && isObject(customMeta.overwrite) ? customMeta.overwrite : {})
  } as AutoFormMergeMeta

  return { decorators, mergedMeta, coreSchema }
}

/**
 * 组件选择逻辑
 * @param mergedMeta - 合并后的元数据
 * @param finalType - 最终类型
 * @param mapping - 控件映射
 * @returns 选择的组件和映射信息
 */
function selectComponent(
  mergedMeta: AutoFormMergeMeta,
  finalType: string | undefined,
  mapping: AutoFormControls
): { chosenComponent: IsComponent | undefined, mapped: AutoFormControl<IsComponent> | undefined } {
  let chosenComponent: IsComponent | undefined
  let mapped: AutoFormControl<IsComponent> | undefined

  if (mergedMeta.component) {
    chosenComponent = mergedMeta.component
  } else if (finalType && finalType in mapping) {
    mapped = mapping[finalType as keyof typeof mapping]
    chosenComponent = mapped?.component
  }

  if (chosenComponent && typeof chosenComponent !== 'string') {
    chosenComponent = markRaw(chosenComponent)
  }

  return { chosenComponent, mapped }
}

/**
 * 字段创建
 */
function createField(
  path: string,
  coreSchema: z.ZodType,
  decorators: AutoFormField['decorators'],
  mergedMeta: AutoFormMergeMeta
): AutoFormField {
  return {
    path,
    schema: coreSchema,
    decorators,
    meta: mergedMeta
  }
}

/**
 * 提取 Zod enum 的枚举值
 * @param schema - Zod enum schema
 * @returns 枚举值数组
 */
function extractEnumValues(schema: z.ZodType): Array<string | number> | undefined {
  // 方法 1: 通过 .enum 属性获取（z.enum() 会暴露）
  if ((schema as any).enum && typeof (schema as any).enum === 'object') {
    return Object.values((schema as any).enum)
  }

  // 方法 2: 通过 _def.values 获取（Zod 内部结构）
  const def = (schema as any)._def
  if (def?.values) {
    // values 可能是 Set 或 Array
    return Array.isArray(def.values) ? def.values : Array.from(def.values)
  }

  return undefined
}

/**
 * 数组字段处理 - 提取数组元素 Schema 并创建数组字段
 */
function handleArrayField(params: {
  schema: z.ZodType
  path: string
  decorators: AutoFormField['decorators']
  meta: AutoFormMergeMeta
  mapping: AutoFormControls
  globalMeta: ZodAutoFormFieldMeta
}): AutoFormField[] {
  const { schema, path, decorators, meta, mapping, globalMeta } = params
  const elementSchema = (schema as any).unwrap?.()

  if (!elementSchema) {
    return []
  }

  const field = createField(path, schema, decorators, { ...meta, type: 'array' })

  const [arrayElement] = introspectSchema(elementSchema, mapping, path, globalMeta)

  if (arrayElement) {
    field.arrayElement = arrayElement
  }

  return [field]
}

/**
 * 对象字段处理 - 递归处理对象的 shape 属性并创建嵌套字段
 */
function handleObjectField(params: {
  schema: z.ZodType
  path: string
  decorators: AutoFormField['decorators']
  meta: AutoFormMergeMeta
  mapping: AutoFormControls
  globalMeta: ZodAutoFormFieldMeta
}): AutoFormField[] {
  const { schema, path, decorators, meta, mapping, globalMeta } = params
  const shape = (schema as any).shape

  if (!shape || typeof shape !== 'object') {
    return []
  }

  const shapeKeys = Object.keys(shape)

  if (shapeKeys.length > AUTOFORM_LIMITS.MAX_OBJECT_PROPERTIES) {
    return []
  }

  if (!path) {
    return shapeKeys.flatMap(key =>
      introspectSchema(shape[key] as z.ZodType, mapping, key, globalMeta)
    )
  }

  const field = createField(path, schema, decorators, meta)
  field.children = shapeKeys.flatMap((key) => {
    const childPath = joinPath([...toPath(path), key])
    return introspectSchema(shape[key] as z.ZodType, mapping, childPath, globalMeta)
  })

  return [field]
}

/**
 * 布局字段处理 - 处理自定义布局字段并重新计算路径
 */
function handleLayoutField(params: {
  schema: z.ZodType
  path: string
  meta: AutoFormMergeMeta
  mapping: AutoFormControls
  globalMeta?: ZodAutoFormFieldMeta
}): AutoFormField[] {
  const { schema, path, meta, mapping, globalMeta = {} } = params
  const shape = meta?.layout?.fields as Record<string, z.ZodType> | undefined

  if (!shape || typeof shape !== 'object') {
    return []
  }

  const pathSegments = toPath(path)
  const actualParentPath = pathSegments.slice(0, -1).join('.')
  const layoutField = createField(path, schema, {}, meta)

  layoutField.children = Object.keys(shape).flatMap((key) => {
    const childSchema = shape[key]
    if (!childSchema) return []

    const childPath = actualParentPath ? `${actualParentPath}.${key}` : key
    return introspectSchema(childSchema, mapping, childPath, globalMeta)
  })

  return [layoutField]
}

/**
 * Schema 内省 - 递归解析 Zod Schema 为表单字段结构
 */
export function introspectSchema(
  schema: z.ZodType,
  mapping: AutoFormControls,
  path: string,
  globalMeta: ZodAutoFormFieldMeta = {}
): AutoFormField[] {
  const fieldName = path.split('.').pop()
  const autoGeneratedLabel = fieldName ? startCase(fieldName) : ''
  const { decorators, mergedMeta, coreSchema } = extractSchemaInfo(schema, globalMeta, autoGeneratedLabel)

  if (!coreSchema) {
    return []
  }

  const fieldType = mergedMeta.type

  if (fieldType === AUTOFORM_META.LAYOUT_KEY) {
    return handleLayoutField({ schema: coreSchema, path, meta: mergedMeta, mapping, globalMeta })
  }

  /**
   * 如果 coreSchema 本身是数组类型，且没有被 overwrite 覆盖，则按数组处理
   * @example
   * z.array(z.number()) -> 数组字段
   * z.number().array() -> 数组字段
   * z.array(z.number(), {type: 'pinInput'}) -> 按照 pinInput 处理，pinInput 本身返回数字数组
   */
  if (fieldType === 'array' || (coreSchema.type === 'array' && !mergedMeta.overwrite)) {
    return handleArrayField({ schema: coreSchema, path, decorators, meta: mergedMeta, mapping, globalMeta })
  }

  if (fieldType === 'object') {
    return handleObjectField({ schema: coreSchema, path, decorators, meta: mergedMeta, mapping, globalMeta })
  }

  const field = createField(path, coreSchema, decorators, mergedMeta)
  const { chosenComponent, mapped } = selectComponent(mergedMeta, fieldType, mapping)

  field.meta.component = chosenComponent
  field.meta.mapped = mapped

  // 枚举类型特殊处理：自动提取枚举值并注入到 controlProps.items
  if (coreSchema.type === 'enum' && mapped) {
    const enumValues = extractEnumValues(coreSchema)
    if (enumValues && enumValues.length > 0) {
      field.meta.mapped = {
        ...mapped,
        controlProps: {
          ...mapped.controlProps,
          items: enumValues
        }
      }
    }
  }

  return [field]
}

/**
 * 判断是否为布局标记字段
 */
function isLayoutMarker(schema: z.ZodType): boolean {
  const { getAutoFormMetadata } = useAutoForm()
  const meta = getAutoFormMetadata(schema)
  return meta?.type === AUTOFORM_META.LAYOUT_KEY
}

/**
 * 处理包含布局标记的 schema shape，提取纯净的数据 schema
 * @param shape - 原始 shape 对象
 * @returns 处理后的纯净 shape（展开所有布局字段）
 */
function processLayoutShape(shape: Record<string, z.ZodType>): Record<string, z.ZodType> {
  const resultShape: Record<string, z.ZodType> = {}

  for (const [key, fieldSchema] of Object.entries(shape)) {
    if (isLayoutMarker(fieldSchema)) {
      // 布局字段：展开其 fields 到 resultShape
      const { getAutoFormMetadata } = useAutoForm()
      const meta = getAutoFormMetadata(fieldSchema)
      const layoutFields = meta?.layout?.fields

      if (layoutFields && isObject(layoutFields)) {
        // 递归处理嵌套布局
        Object.assign(resultShape, processLayoutShape(layoutFields))
      }
    } else {
      // 普通字段：直接保留
      resultShape[key] = fieldSchema
    }
  }

  return resultShape
}

/**
 * 提取纯净的数据 schema（去除所有布局标记）
 * @param schema - 包含布局标记的 ZodObject
 * @returns 纯净的 ZodObject，只包含数据字段
 */
export function extractPureSchema<T extends z.ZodObject<any, any>>(schema: T): z.ZodObject<any, any> {
  const shape = (schema as any).shape

  if (!shape || typeof shape !== 'object') {
    return schema
  }

  // 检查是否包含布局标记
  const hasLayoutMarker = Object.values(shape).some(fieldSchema =>
    isLayoutMarker(fieldSchema as z.ZodType)
  )

  // 没有布局标记，直接返回原 schema
  if (!hasLayoutMarker) {
    return schema
  }

  // 处理 shape，提取纯净字段
  const pureShape = processLayoutShape(shape)

  // 创建新的 ZodObject
  return zod.object(pureShape) as z.ZodObject<any, any>
}
